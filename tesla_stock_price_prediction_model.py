# -*- coding: utf-8 -*-
"""Tesla_Stock_Price_Prediction_Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mqKM8hUeR0IXVbsTff-9FEetfIuDB5K2

# Import dependencies
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.preprocessing import MinMaxScaler

# Load the Tesla stock price data
df = pd.read_csv('/content/Tesla_raw_data.csv')
df.head()

# Extract the 'Close' prices as the target variable
data = df['close'].values.reshape(-1, 1)
data.shape

df.info()

"""### Finding the null value

# The below line is to caliculate the number of missing values in the dataframe df
"""

df.isnull().sum()

#  replace NaN values with zeros
df.fillna(0)

"""*the below line is to understand the statistical view of the data *

**Count:** The number of non-null values in each column.

**Mean:** The average value of each column.

**Std:** The standard deviation, which measures the dispersion of values around the mean.

**Min:** The minimum value in each column.

**25%, 50%, 75%:** The quartiles, which represent the values below which a given percentage of observations fall. The 50% is the median.

**Max:** The maximum value in each column.
"""

df.describe()

df.shape

# Normalize the data between 0 and 1
scaler = MinMaxScaler()
data = scaler.fit_transform(data)
print(data[0:10])
print("shape of data",data.shape) # remember data is the close column value of the dataset

# Define a function to create sequences and labels for training
def create_sequences(data, sequence_length):
    X, y = [], []
    for i in range(len(data) - sequence_length):
        X.append(data[i:i+sequence_length])
        y.append(data[i+sequence_length:i+sequence_length+1])  # Include only the next value as the label
    return np.array(X), np.array(y)

# Set the sequence length (number of time steps to look back)
sequence_length = 20

data.shape

# Create sequences and labels
X, y = create_sequences(data, sequence_length)

print(X.shape)
print(y.shape)

"""# Plotting the stock prices of Tesla"""

# Plotting the stock prices of Tesla
# Line plot

fig, ax = plt.subplots(figsize=(20, 8))
ax.plot(df['date'], df['close'], color='green')  # Use df.index for the date and 'Close' for the closing prices
ax.xaxis.set_major_locator(plt.MaxNLocator(15))
ax.set_xlabel('date', fontsize=14)  # Correct the label to 'Date'
ax.set_ylabel('Price in USD', fontsize=14)
plt.title('Tesla Stock Prices', fontsize=18)
plt.grid()
plt.show()

# Bar plot
fig2, ax = plt.subplots(figsize=(20, 8))
ax.bar(df['date'], df['close'], color='green')
ax.xaxis.set_major_locator(plt.MaxNLocator(15))
ax.set_xlabel('date', fontsize=14)
ax.set_ylabel('Price in USD', fontsize=14)
plt.title('Tesla Stock Prices', fontsize=18)
plt.grid()
plt.show()

"""# Volume Visualization"""

# Plotting the volume trends of Tesla stock

# Line plot
fig, ax = plt.subplots(figsize=(20, 8))
ax.plot(df['date'], df['volume'])
ax.xaxis.set_major_locator(plt.MaxNLocator(15))
ax.set_xlabel('Date', fontsize=14)
ax.set_ylabel('Volumes', fontsize=14)
plt.title('Tesla Volume Trends', fontsize=18)
plt.grid()
plt.show()

# Bar plot
fig2, ax = plt.subplots(figsize=(20, 8))
ax.bar(df['date'], df['volume'])
ax.xaxis.set_major_locator(plt.MaxNLocator(15))
ax.set_xlabel('Date', fontsize=16)
ax.set_ylabel('Volumes', fontsize=16)
plt.title('Tesla Volume Trends', fontsize=18)
plt.grid()
plt.show()

"""         date       close




0     2024-03-01        100

1  2024-03-02          110

2  2024-03-03    105

3  2024-03-04    115

4  2024-03-05    120

After cal of df['volume'] = (df['close'] / df['close'].shift(1)) - 1

For the first row, there is no previous day's closing price, so



the percentage change is NaN (Not a Number).

For the second row, the percentage change is calculated as (110 / 100) - 1 = 0.10, indicating a 10% increase from the previous day's closing price.

For the third row, the percentage change is calculated as (105 / 110) - 1 = -0.05, indicating a 5% decrease from the previous day's closing price.

For the fourth row, the percentage change is calculated as (115 / 105) - 1 = 0.10, indicating a 10% increase from the previous day's closing price.

For the fifth row, the percentage change is calculated as (120 / 115) - 1 = 0.04, indicating a 4% increase from the previous day's closing price

         date  close  volume
0  2024-03-01    100     NaN

1  2024-03-02    110    0.10

2  2024-03-03    105   -0.05

3  2024-03-04    115    0.10

4  2024-03-05    120    0.04

"""

# Calculate the daily volumeatility
df['volume'] = (df['close'] / df['close'].shift(1)) - 1

# Create the line plot for volumeatility
fig, ax = plt.subplots(figsize=(20, 8))
ax.plot(df['date'], df['volume'], color='purple')
ax.xaxis.set_major_locator(plt.MaxNLocator(15))
plt.title('Volumeatility', fontsize=14)
plt.grid()
plt.show()

# Create the bar plot for volumeatility
fig1, ax = plt.subplots(figsize=(20, 8))
ax.bar(df['date'], df['volume'], color='purple')
ax.xaxis.set_major_locator(plt.MaxNLocator(15))
plt.title('Volumeatility', fontsize=14)
plt.grid()
plt.show()

# Create the histogram for volumeatility
plt.figure(figsize=(10, 6))
df['volume'].hist(bins=1000, color='red')
plt.title('volumeatility Distribution', fontsize=14)
plt.xlabel('voltility')
plt.ylabel('Frequency')
plt.show()

"""         date  close  volume
0  2024-03-01    100     NaN

1  2024-03-02    110    0.10

2  2024-03-03    105   -0.05

3  2024-03-04    115    0.10

4  2024-03-05    120    0.04

after applying df['Cumulative Return'] = (1 + df['volume']).cumprod()


         date  close  volume  Cumulative Return

0  2024-03-01    100     NaN                NaN

1  2024-03-02    110    0.10           1.100000

2  2024-03-03    105   -0.05           1.045000

3  2024-03-04    115    0.10           1.149500

4  2024-03-05    120    0.04           1.195380



**Process:**
For the first row, there is no previous value, so the cumulative return is NaN (Not a Number).

For the second row, the cumulative return is calculated as (1 + 0.10) = 1.10.

For the third row, the cumulative return is calculated as (1 + (-0.05)) * 1.10 = 1.045.

For the fourth row, the cumulative return is calculated as (1 + 0.10) * 1.045 = 1.1495.

For the fifth row, the cumulative return is calculated as (1 + 0.04) * 1.1495 = 1.19538.
"""

# Calculate the cumulative return
df['Cumulative Return'] = (1 + df['volume']).cumprod()

# Create the bar plot for cumulative return
fig, ax = plt.subplots(figsize=(20, 8))
ax.bar(df['date'], df['Cumulative Return'], color='violet')
ax.xaxis.set_major_locator(plt.MaxNLocator(15))
ax.set_xlabel('Date', fontsize=14)
ax.set_ylabel('Cumulative Return', fontsize=14)
plt.title('Cumulative Return', fontsize=14)
plt.grid()
plt.show()

# to perform various date and time opperations in pandas of datetime objects.
df['date'] = pd.to_datetime(df['date'])

"""# Calander Effect"""

# Calculate the daily returns
df['Return'] = df['close'].pct_change() # percentage change

# Extract the month and year from the 'date' column
df['Month'] = df['date'].dt.month_name()
df['Year'] = df['date'].dt.year

# Group the data by month and year and calculate the average return
monthly_returns = df.groupby(['Month', 'Year'])['Return'].mean().reset_index()

# Define the desired order of months
month_order = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']

# Sort the data by month order
monthly_returns['Month'] = pd.Categorical(monthly_returns['Month'], categories=month_order, ordered=True)
monthly_returns = monthly_returns.sort_values('Month')

# Create a bar plot of the average monthly returns
plt.figure(figsize=(12, 6))
sns.barplot(data=monthly_returns, x='Month', y='Return')
plt.title('Average Monthly Returns')
plt.xlabel('Month')
plt.ylabel('Returns')
plt.show()

# Extract the year from the 'date' column
df['Year'] = df['date'].dt.year

# Group the data by year and calculate the average return
yearly_returns = df.groupby(['Year'])['Return'].mean().reset_index()

# Sort the data by year
yearly_returns = yearly_returns.sort_values('Year')

# Create a bar plot of the average yearly returns
plt.figure(figsize=(12, 6))
sns.barplot(data=yearly_returns, x='Year', y='Return')
plt.title('Average Yearly Returns')
plt.xlabel('Year')
plt.ylabel('Returns')
plt.show()

# Extract the day of the week from the 'Date' column
df['Day'] = df['date'].dt.weekday

# Group the data by day of the week and calculate the average return
daily_returns = df.groupby(['Day'])['Return'].mean().reset_index()

# Sort the data by day of the week
daily_returns = daily_returns.sort_values('Day')

# Create a bar plot of the average daily returns
plt.figure(figsize=(12, 6))
sns.barplot(data=daily_returns, x='Day', y='Return')
plt.title('Average Day of Week Returns')
plt.xlabel('Days')
plt.ylabel('Returns')
plt.show()

"""df['close'].rolling(10).mean(): This calculates the 10-day moving average of the closing prices. It takes the rolling window of size 10 (i.e., the closing prices of the last 10 days), computes the mean of these prices for each day, and assigns the result to a new column named 'MA for 10 days' in the DataFrame df."""

df.describe()
#df.shape

# Calculate moving averages for different windows
df['MA for 10 days'] = df['close'].rolling(10).mean()
df['MA for 20 days'] = df['close'].rolling(20).mean()
df['MA for 50 days'] = df['close'].rolling(50).mean()
df['MA for 100 days'] = df['close'].rolling(100).mean()

# Truncate the data if needed
#The truncate() method in Python resizes the file to a specified size. If no size is given, it uses the current file position.
truncated_data = df.truncate()

# Plot the adjusted close price and moving averages
truncated_data[['close', 'MA for 10 days', 'MA for 20 days', 'MA for 50 days', 'MA for 100 days']].plot(subplots=False, figsize=(12, 5))

# Set the title and axis labels
plt.title('Tesla Stock: Adjusted Close Price and Moving Averages')
plt.xlabel('Date')
plt.ylabel('Price')

# Display the plot
plt.show()

df.describe()
#df.shape

#plotting bollinger band
rolling_mean = df['close'].rolling(window=20).mean()
rolling_std = df['close'].rolling(window=20).std()
upper_band = rolling_mean + (rolling_std * 2)
lower_band = rolling_mean - (rolling_std * 2)
fig, ax = plt.subplots(figsize=(10,6))
ax.plot(df.index, df['close'], label='close')
ax.plot(rolling_mean.index, rolling_mean, label='Rolling Mean')
ax.fill_between(rolling_mean.index, upper_band, lower_band, alpha=0.4, color='black', label='Bollinger Bands')
ax.legend()
plt.show()

"""#  Tesla Stock movement in the year of 2023"""

a=df[df['date'] <= '2022-12-31'].index
b=df.drop(a)

plt.plot(b.date,b.close)
plt.show

"""# Profitable days vs Loss days"""

gain=df[df['change_percent']<0]['date'].count()
lost=df[df['change_percent']>0]['date'].count()

labels=['Gain','Lost']
sizes=[gain,lost]
colors=['g','r']
plt.pie(sizes,labels=labels,autopct='%1.f%%',colors=colors)

plt.show

# Split the data into training and testing sets
train_size = int(0.8 * len(X))
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

"""# LSTM

"""

# Build an LSTM model
model = Sequential()
model.add(LSTM(units=50, activation='relu', input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(Dense(units=1))
model.compile(optimizer='adam', loss='mean_squared_error')

print(f"X_train shape: {X_train.shape}")
print(f"y_train shape: {y_train.shape}")

# Train the model
model.fit(X_train, y_train, epochs=50, batch_size=32)

# Evaluate the model
train_loss = model.evaluate(X_train, y_train, verbose=0)
test_loss = model.evaluate(X_test, y_test, verbose=0)
print(f'Training Loss: {train_loss}')
print(f'Testing Loss: {test_loss}')

# Make predictions on the test data
y_pred = model.predict(X_test)

# Inverse transform the predictions to get actual stock prices
y_pred = scaler.inverse_transform(y_pred)
#y_test_actual = scaler.inverse_transform(y_test)
print(y_test.shape)
if y_test.shape[1] == 1:
    y_test = y_test.reshape((y_test.shape[0], 1))
y_test_actual = scaler.inverse_transform(y_test)

# Plot the actual vs. predicted stock prices
plt.figure(figsize=(12, 6))
plt.plot(y_test_actual, label='Actual Prices')
plt.plot(y_pred, label='Predicted Prices')
plt.title('Tesla Stock Price Prediction')
plt.xlabel('Time')
plt.ylabel('Stock Price')
plt.legend()
plt.show()

from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

if __name__ == '__main__':
    app.run(debug=True)

